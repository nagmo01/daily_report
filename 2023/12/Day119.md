# 2023/12/21の日報


## 取り組んだこと
- カート機能の修正
- herokuデプロイ

## わかったこと
- マイグレーションファイルは可逆的である必要がある。なのでchangeとup,downを使い分ける
- テーブルを変更したいときはdbを消してマイグレーションファイルを編集するか、新たにマイグレーションファイルを作成して変更したい記述を書く
- 


## 次やること
- herokuのデプロイがうまくいかないので直す
- PR出す
- チェックアウト機能に入る

## 感じたこと

## 学習時間
- TODAY: 6h
- TOTAL: 515.5h


# 今日やること

- PR再提出
- チェックアウト機能を考えていく。



## 今日の学習メモ

- マイグレーションファイル＝DBに対する指示書
- マイグレーション＝指示書の内容をDBに適用
- 修正、追加、削除などは全て新しいマイグレーションファイルを作成して行う。
- なんとなく修正や追加は既存のマイグレーションファイルに記述を加えたりしてもう一度migrateを実行するのかなと思っていたので違った。
- マイグレーションファイルは設計図なので設計図を消したところで適用されているものは消えないというのはわかりやすい気がする。
- データベースに新しい変化を加えたいときは常にマイグレーションファイルを新しく用意してそこに変更する記述を書いてmigrateで適用させていく。
#### 気になるポイント
- 一回のマイグレーションを実行したときに一つのマイグレーションファイルが１つのバージョンとして記録されていくのかgitのaddとcommitみたいな感じでmigrateするときに存在するマイグレーションファイルは全て一回のバージョンとして適用されていく仕組みになっているのか。
- たぶん後者だとは思う。その場合削除などをしたい場合はrollbackは使いにくそうだしmigrationファイルを作成して行わなければいけなさそうだなーと思った。
- マイグレーションファイルの名前はなんでもいいのか？というか自由に命名して問題ないのか、特定の予約語みたいなものがあり、命名自体が実行する役割になっているとかではないか？

migrationファイル内のメソッド

changeメソッドを使うのは単純な足し引きにしておく。
そうするとrollback時も逆処理を行うだけで正常に戻せる。
カラムのデータ型の変更などはchangeで変えてしまうとrollbackで戻せなくなるので
upメソッドとdownメソッドの両方を記述することでmigrate時とrollback時の両方の処理を明示的に書いてあげるとうまく戻したりあげたりできる。


### `change`メソッドがサポートしているマイグレーションは以下の通りです。

- `add_column`
テーブルに新しいカラムを追加する。カラム名と型を指定します。
- `add_index`
- `add_reference`
- `add_timestamps`
- `create_table`
- `create_join_table`
- `drop_table (ブロックのみ)`
- `drop_join_table (ブロックのみ)`
- `remove_timestamps`
- `remove_reference`
- `rename_column`
- `rename_index`
- `rename_table`


``$rails db:migrate:status``で現在適用されているマイグレーションファイルを確認できる。

![[スクリーンショット 2023-12-21 15.35.56.png]]
upになっているものが適用済み。
downのものがまだ作成されているが適用されていないファイル。

| メソッド | 説明 |
| --- | --- |
| `add_column` | テーブルに新しいカラムを追加します。 |
| `add_index` | テーブルのカラムにインデックスを追加します。これにより、そのカラムでの検索速度が向上します。 |
| `add_reference` | テーブルに新しい外部キーを追加します。これは、他のテーブルとの間に関連性を作るために使用されます。 |
| `add_timestamps` | テーブルに`created_at`と`updated_at`の2つの新しいカラムを追加します。これらのカラムは、レコードがいつ作成または更新されたかを自動的に追跡します。 |
| `create_table` | 新しいテーブルを作成します。 |
| `create_join_table` | 2つのテーブル間の「結合テーブル」を作成します。これは、多対多の関連性を作るために使用されます。 |
| `drop_table` | テーブルを削除します。ただし、この操作はブロック内でのみ使用できます。 |
| `drop_join_table` | 結合テーブルを削除します。ただし、この操作はブロック内でのみ使用できます。 |
| `remove_timestamps` | テーブルから`created_at`と`updated_at`のカラムを削除します。 |
| `remove_reference` | テーブルから外部キーを削除します。 |
| `rename_column` | テーブルのカラム名を変更します。 |
| `rename_index` | テーブルのインデックス名を変更します。 |
| `rename_table` | テーブル名を変更します。 |

## change、up、downメソッドについて

マイグレーションはバージョンになっているため、
可逆性がなければいけない。

通常は何もない状態から何かを変更したいと発露し、
そのためのマイグレーションファイルを作成し、
migrateする

修正（変更）、追加、削除が主に作業としてあると思うが、
このときに追加、削除に関しては基本的にchangeメソッドで記述するべきだと思われる。

理由として前述の可逆性の話に戻るが
マイグレーションでは
changeメソッド内に
１と記述することで
migrate時には-1をするという作業を行い、
rollback時には-1をするという作業を行うように解釈される。

なのであるテーブルからindexカラムを削除するという記述をしたときは
rollback時にはその逆操作をそのファイルをもう一度参照して行われているだけになる。
対象物が同一のケースはこの作業で済むが、

例えばすでに存在するカラムuserをaccountに変えたい　といったようなときは
migrateをしたあとにrollbackを行うだけでは
逆操作は行えない。
こういう場合には
upメソッドとdownメソッドを両方定義して
migrate時に処理とrollback時の処理を両方記述しておく。


**Railsのmodelとは、「データベースとのやり取りを行うクラスのこと」**

**Railsのmodelは、データベースのテーブルに対応するRubyのクラスです。**モデルクラスのインスタンスは、1つの行(**レコード**)を表すオブジェクトになり、テーブルの列(**カラム**)に相当する属性を持ちます。

例えば、商品情報のモデルクラスがあると、そのインスタンス(オブジェクト)は「商品名」や「価格」などの属性を持ちます。


## 同時に複数のマイグレーションファイルをmigrateするとき

rails db:dropで一度DBを消してからもう一度createしたあとなどは
マイグレーションファイルがもうすでにある程度存在している状態からmigrateすることになると思う。
基本的には順番に追加しているため、そのまま実行すると問題ないはずだが、
例えばDBを消すと直接そのマイグレーションファイル自体を編集してテーブル構成を変更することも可能になる。

例として
userテーブル作成
itemテーブル作成
user_itemテーブル作成
という流れがあったときに
user_itemテーブルは外部キーなどがあるためすでにuser,itemテーブルが作成されているあとでしか定義できない。
ファイルを直接いじるとこのような前後関係が崩れる時がある。
そういう場合は
``20231234045808_create_cart_items.rb``のようなファイル名の数字の部分が日付になっていて
ここの日時が若い順から実行されていくため、都合の良いファイルより遅くしたり早くしたりをファイル名変更でいじれば良い。


``rails db:migrate:status``は相当便利。

共同で作業していてすでにマイグレーションファイルを他の開発者が適用している場合にテーブルを変更する場合はあらたなマイグレーションファイルを作成することが必須になる。
自分一人でやっている場合は最悪rails db:dropでDBを消してからマイグレーションファイルをいじってまたmigrateをしてもできる。というかそっちの方がいいかもしれん。


### herokuのデータベースをリセットしたいとき
Railsだとproductionに保護機能がついている。
ネットではrails db:drop RAILS_ENV=production〜
のようなrails側のコマンドで可能と書いてあったができなかった。
調べた結果
ターミナルで``heroku pg:reset -a アプリ名``
でできた。
pgなのでpostgresがDBだった場合だと思われるが。
ようはheroku側に対する命令で行った方がよさそう。

アプリ名ってのはpeaceful-waveのようなもの。

完了できたら
rails db:migrateでおk
