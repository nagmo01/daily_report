# 2023/12/14の日報


## 取り組んだこと
- session[:sisson_id]でブラウザを識別できるようにした。
- カートテーブルに商品を追加できるようにした。


## わかったこと
- sessionの使い方

## 次やること
- RailsのEC課題 - session & カート機能
- 現状だと商品１が違うタイミングで追加されると異なるレコードになってしまうのでそこを元のレコードに数量だけ追加する形に変えたい。
 
## 感じたこと
- モデルが複数出てきて複雑になってきた。

## 学習時間
- TODAY: 6h
- TOTAL: 488h


## 今日学んだメモ


## セッションとは
セッションの中に
cookiesがある。

クッキーはユーザーのブラウザに保存されるテキストデータ
あるページから別のページに移動した時には破棄されないため、ユーザーのログインIDなどの保存が可能になる。
要は毎ページごとに条件分岐でユーザーIDの確認だけすればいい状態
アプリはクッキーに保存されているユーザーIDなどを利用してログイン中のユーザーの所有する情報をDBから取り出したりできる。

### Railsのsessionメソッド
ここでいうsessionはHTTPプロトコルなどと並んで使われるセッションというワードとは別の話。セッションという概念があり、それをrailsで実現するための具体的なメソッドとしてこのsessionやあとあと出てくるcookiesがある。

sessionメソッドは一時セッションを作成するもの。
一時セッションのためブラウザを閉じると自動的に終了する。

### Railsのcookiesメソッド
こちらはブラウザを閉じた時にも消えない。


## EC課題に使うなら

今回作るECサイトではユーザーのログイン機能はないため、ブラウザを閉じるまで継続される一時セッションで十分だと思う。
なので**sessionメソッドを利用する。**



### ストロングパラメータについて

viewのフォームから入力された情報をコントローラでモデルに利用したい場合などにストロングパラメータが適用される。

ただし、
user = User.new
user.email = params[:email]
のように１カラムずつデータを指定して行う場合はストロングパラメータは不要。
#### なぜか？
**ストロングパラメータでどういうことが防げるか？**

例えばUserモデルがあり、属性が
name, email, password, admin, created_at, updated_atなどがあるときに
こちら側がviewのフォームで想定している部分が
name, email, passwordのみなのに対して、
悪意あるユーザーにadmin, created_at, updated_atなどを更新されてしまうことを危惧して、用意されている機能のため、
1カラムずつ手動で代入する記述をしていく場合、想定外のカラムが更新される心配自体ないのでストロングパラメータの対象外になる。

##### 思ったこと
ストロングパラメータ使うより一つずつ記述した方がわかりやすいし、よくないか？カラムが多すぎた場合などはめんどくさいということなのだろうか

#### 補足
##### mergeメソッド

mergeメソッドを使用することでハッシュ同士を結合することができます。  
例えば、paramsに含まれない値をストロングメソッドに加えたい場合などに、ストロングパラメータの後に記述することができます。

```
params.require(:user).permit(:name,:email).merge(user_id: current_user.id)
```


参考URL
https://qiita.com/ozackiee/items/f100fd51f4839b3fdca8


### 外部キー制約
例えばカートモデル内でitemモデルのidやuserモデルのidをカラムとして使う場合、特に何もせず対応する数字のみを保存しておいても
user = User.find_by(id: cart.user_id)
のような記述をすれば取り出すことは可能。

なぜマイグレーションファイルに
t. references :user foreign_key :true
のような記述をして外部キーとして設定するのか？

### 外部キーを設定すると
1. 存在しない値を外部キーとして登録することはできない  
2. 子テーブルの外部キーに値が登録されている親テーブルのレコードは削除できない

1についてはわかりやすいと思うが、カートモデルに保存しようとしているitem_idがitemモデルに存在しないidの場合エラーが起こる。
実装上あまり起こり得なさそう？

2について
子テーブルの外部キーに値が登録されている親テーブルのレコードは削除できない
子と親の関係性がイマイチ把握しづらい。
多分外部キーをカラムの一部として使っている側が子になる。
Userが親でCartが子
なので例えばカートテーブルにitem_idの登録がある商品に関してはアイテムテーブルからレコードを削除できない。
ということになる。カートに入っている商品は出品取り消しができない状態になるのでこの場合は意外と微妙そう。

ただ、しっかり販売数量などがあるタイプの設計なら購入時に
在庫の条件分岐を行えば済むのでそこまで問題にはならなさそう。

## テーブルの関係は1対多なのか多対１なのかわからなくなった時
### 1つの○○(A)に1つの○○(B)が結びついている
成立しているならAのモデルに
``app/models/A.rb``
```
class A < applicationRecord
  belongs_to :B
```

### 1つの○○(A)に複数の○○(B)が結びついている
``app/models/A.rb``
```
class A < applicationRecord
  has_many :B
```

上のテンプレートに両方のモデルを当てはめてみて決めると良い。

例 記事とコメントの関係なら

Q.一つの記事に一つのコメントが結びついている
は一つの記事に複数のコメントが結びついているケースがほとんどなので間違い。
A.一つの記事に複数のコメントが結びついている

Q.一つのコメントに一つの記事が結びついている
は一つのコメントは一つの記事に対して投稿されているものなので○
A. 正解


##  link_toでpostへのリクエスト送信がうまくいかなかった。

#### A. Rails7でlink_toでの記述が変わっていたため。
```
<%= link_to "Add to Cart", "/cart/:id", data: { turbo_method: :post } %>
```

のよう記述する必要があった。
